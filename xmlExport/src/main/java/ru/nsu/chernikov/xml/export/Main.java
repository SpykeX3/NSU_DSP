/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.chernikov.xml.export;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class Main {
    private static final int threads = Math.max(Runtime.getRuntime().availableProcessors(), 1);
    private static final String createPersonTable =
            "CREATE TABLE IF NOT EXISTS persons_table("
                    + "id varchar(8) NOT NULL PRIMARY KEY,"
                    + "gender varchar(2) NOT NULL,"
                    + "firstname varchar(255) NOT NULL,"
                    + "lastname varchar(255) NOT NULL,"
                    + "CONSTRAINT gender_check CHECK (gender IN ('M', 'F'))"
                    + ")";
    private static final String createRelTable =
            "CREATE TABLE IF NOT EXISTS relations_table("
                    + "first_id varchar(8) NOT NULL,"
                    + "relation varchar(16) NOT NULL,"
                    + "second_id varchar(8) NOT NULL,"
                    + "CONSTRAINT relation_check CHECK (relation "
                    + "IN ('MOTHER', 'FATHER', 'SISTER', 'BROTHER',"
                    + " 'SON', 'DAUGHTER', 'SPOUSE'))"
                    + ")";
    private static final String insertPerson = "INSERT INTO persons_table VALUES (?, ?, ?, ?)";
    private static final String insertRelation = "INSERT INTO relations_table VALUES (?, ?, ?)";

    private static final String alterRelTable =
            "ALTER TABLE relations_table "
                    + "ADD FOREIGN KEY (first_id) REFERENCES persons_table(id), "
                    + "ADD FOREIGN KEY (second_id) REFERENCES persons_table(id)";

    private static BufferedReader getXMLReader() {
        return new BufferedReader(new InputStreamReader(Objects.requireNonNull(Main.class.getResourceAsStream(
                "/human_race.xml"))));
    }

    public static void main(String[] args) {
        System.out.println("Starting");
        List<File> xmlFiles = new ArrayList<>();
        File xml;
        Path tmpDir = null;
        try {
            tmpDir = Files.createTempDirectory("people_split");
            int linesCnt = 0;
            try (BufferedReader br = getXMLReader()) {
                while (br.readLine() != null) {
                    linesCnt++;
                }
            }
            int chunkSize = linesCnt / threads;
            try (BufferedReader br = getXMLReader()) {
                for (int i = 0; i < threads; i++) {
                    Path tmpFile = Files.createTempFile(tmpDir, "tmp" + i + ".xml", null);
                    try (BufferedWriter bw = new BufferedWriter(new FileWriter(tmpFile.toFile()))) {
                        if (i > 0) {
                            bw.write(
                                    "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n"
                                            + "<ns2:persons xmlns:ns2=\"http://xml1/persons\">\n");
                            bw.flush();
                        }
                        String s = null;
                        for (int j = 0; j < chunkSize; j++) {
                            s = br.readLine();
                            if (s == null) {
                                break;
                            }
                            bw.write(s + "\n");
                            bw.flush();
                        }
                        if (s == null) {
                            if (i < threads - 1) {
                                bw.write("</ns2:persons>");
                                bw.flush();
                            }
                            xmlFiles.add(tmpFile.toFile());
                            break;
                        }
                        if (!s.contains("</person>")) {
                            s = br.readLine();
                            while (s != null) {
                                bw.write(s + "\n");
                                bw.flush();
                                if (s.contains("</person>")) {
                                    break;
                                }
                                s = br.readLine();
                            }
                        }
                        if (i == threads - 1 && s != null) {
                            while (s != null) {
                                bw.write(s + "\n");
                                bw.flush();
                                s = br.readLine();
                            }
                        }
                        if (i < threads - 1) {
                            bw.write("</ns2:persons>");
                            bw.flush();
                        }
                    }
                    xmlFiles.add(tmpFile.toFile());
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("Connecting to the DB");
        try (Connection connection =
                     DriverManager.getConnection(
                             "jdbc:postgresql://localhost:2999/postgres", "postgres", "postgres")) {
            Statement statement = connection.createStatement();
            statement.executeUpdate("DROP TABLE IF EXISTS relations_table  ");
            statement.executeUpdate("DROP TABLE IF EXISTS persons_table ");

            System.out.println("Creating tables");
            statement.executeUpdate(createPersonTable);
            statement.executeUpdate(createRelTable);

            System.out.println("Processing xmls");
            List<Thread> workers = new ArrayList<>();
            for (int i = 0; i < threads; i++) {
                workers.add(
                        new Thread(
                                new XmlDBProcessor(
                                        connection.prepareStatement(insertPerson),
                                        connection.prepareStatement(insertRelation),
                                        xmlFiles.get(i))));
            }
            workers.forEach(Thread::start);
            try {
                for (Thread worker : workers) {
                    worker.join();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
                return;
            }

            statement.executeUpdate(alterRelTable);
        } catch (SQLException e) {
            e.printStackTrace();
        }

        xmlFiles.forEach(File::deleteOnExit);
        if (tmpDir != null) {
            tmpDir.toFile().deleteOnExit();
        }
    }
}
